<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="morisa"><meta name="copyright" content="morisa"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>并发Concurrency | Little Web</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.24/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="shortcut icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"morisa66.github.io","root":"/","title":"难为君子|不做小人","version":"1.5.1","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><meta name="description" content="并发 Concurrency 概述 早期，由于摩尔定律带来的免费性能提升，高速的 Intel 单 CPU 是性价比最高的系统架构，没必要进行并发编程。 随之而来的主频提升停滞，（2001 年，Intel 已经有了主频 2.0 GHz 的 CPU，但目前我的PC主频是 2.1 GHz），服务器、台式机、笔记本、移动设备的处理器都转向了多核，计算要求则从单线程变成了多线程甚至异构，即不仅要使用">
<meta property="og:type" content="article">
<meta property="og:title" content="并发Concurrency">
<meta property="og:url" content="https://morisa66.github.io/2021/02/12/Concurrency/index.html">
<meta property="og:site_name" content="Little Web">
<meta property="og:description" content="并发 Concurrency 概述 早期，由于摩尔定律带来的免费性能提升，高速的 Intel 单 CPU 是性价比最高的系统架构，没必要进行并发编程。 随之而来的主频提升停滞，（2001 年，Intel 已经有了主频 2.0 GHz 的 CPU，但目前我的PC主频是 2.1 GHz），服务器、台式机、笔记本、移动设备的处理器都转向了多核，计算要求则从单线程变成了多线程甚至异构，即不仅要使用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/morisa66/BlogImgs/master/cpp/Concurrency/atomic.png">
<meta property="article:published_time" content="2021-02-12T03:07:56.000Z">
<meta property="article:modified_time" content="2021-02-14T15:43:10.000Z">
<meta property="article:author" content="morisa">
<meta property="article:tag" content="CPP">
<meta property="article:tag" content="Concurrency">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/morisa66/BlogImgs/master/cpp/Concurrency/atomic.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="morisa"><img width="96" loading="lazy" src="/imgs/avatar.jpg" alt="morisa"></a><div class="site-author-name"><a href="/about/">morisa</a></div><a class="site-name" href="/about/site.html">Little Web</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">27</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">4</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">15</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/morisa66" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/morisa-48" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/289542802" title="B站" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/morisa66" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="morisa66@outlook.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91-concurrency"><span class="toc-number">1.</span> <span class="toc-text">并发 Concurrency</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mutex"><span class="toc-number">1.3.</span> <span class="toc-text">mutex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread"><span class="toc-number">1.4.</span> <span class="toc-text">thread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#thread-%E5%B0%81%E8%A3%85"><span class="toc-number">1.5.</span> <span class="toc-text">thread 封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">1.6.</span> <span class="toc-text">锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE"><span class="toc-number">1.7.</span> <span class="toc-text">返回数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#notify_one-%E4%B8%8E-notify_all"><span class="toc-number">1.8.</span> <span class="toc-text">notify_one() 与 notify_all()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#future"><span class="toc-number">1.9.</span> <span class="toc-text">future</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise"><span class="toc-number">1.10.</span> <span class="toc-text">promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#packaged_task"><span class="toc-number">1.11.</span> <span class="toc-text">packaged_task</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.12.</span> <span class="toc-text">执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c11-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.13.</span> <span class="toc-text">C++11 内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#atomic"><span class="toc-number">1.14.</span> <span class="toc-text">atomic</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A"><span class="toc-number">1.15.</span> <span class="toc-text">安全双重检查锁定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">1.16.</span> <span class="toc-text">一些问题</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://morisa66.github.io/2021/02/12/Concurrency/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="morisa"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Little Web"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">并发Concurrency</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-02-12 11:07:56" itemprop="dateCreated datePublished" datetime="2021-02-12T11:07:56+08:00">2021-02-12</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2021-02-14 23:43:10" itemprop="dateModified" datetime="2021-02-14T23:43:10+08:00">2021-02-14</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">基础技术</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/CPP/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">CPP</span></a><a class="tag" href="/tags/Concurrency/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">Concurrency</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h1 id="并发-concurrency">并发 Concurrency</h1>
<h2 id="概述">概述</h2>
<p>早期，由于摩尔定律带来的免费性能提升，高速的 Intel 单 CPU 是性价比最高的系统架构，没必要进行并发编程。</p>
<p>随之而来的主频提升停滞，（2001 年，Intel 已经有了主频 2.0 GHz 的 CPU，但目前我的PC主频是 2.1 GHz），服务器、台式机、笔记本、移动设备的处理器都转向了多核，计算要求则从单线程变成了多线程甚至异构，即不仅要使用 CPU，还得使用 GPU。</p>
<h2 id="进程和线程">进程和线程</h2>
<p>编译完执行的 C++ 程序，在操作系统看来就是一个进程，每个进程里可以有一个或多个线程。</p>
<ul>
<li>每个进程有自己的独立地址空间，不与其他进程分享；一个进程里可以有多个线程，共享同一个地址空间。</li>
<li>堆内存、文件、套接字等资源都归进程管理，同一个进程里的多个线程可以共享使用。</li>
<li>每个进程占用的内存和其他资源，会在进程退出或被杀死时返回给操作系统。</li>
<li>并发应用开发可以用多进程或多线程的方式。多线程由于可以共享资源，效率较高；反之，多进程（默认）不共享地址空间和资源，开发较为麻烦，在需要共享数据时效率也较低。</li>
<li>多进程安全性较好，在某一个进程出问题时，其他进程一般不受影响；而在多线程的情况下，一个线程执行了非法操作会导致整个进程退出。</li>
</ul>
<p>C++ 里的并发，主要是多线程，从纯逻辑的角度，并发的思维模式比单线程更为困难。其中部分难点如下：</p>
<ul>
<li>编译器和处理器的重排问题</li>
<li>原子操作和数据竞争</li>
<li>互斥锁和死锁问题</li>
<li>无锁算法</li>
<li>条件变量</li>
<li>信号量</li>
</ul>
<h2 id="mutex">mutex</h2>
<p>互斥量的基本语义是，一个互斥量只能被一个线程锁定，用来保护某个代码块在同一时间只能被一个线程执行。</p>
<p>C++ 标准中，提供了不止一个互斥量类，最简单、最常用的 mutex 类。</p>
<p>mutex 只可默认构造，不可拷贝（或移动），不可赋值，主要提供的方法是：</p>
<ul>
<li>lock：锁定，锁已经被其他线程获得时则阻塞执行</li>
<li>try_lock：尝试锁定，获得锁返回 true，在锁被其他线程获得时返回 false</li>
<li>unlock：解除锁定（只允许在已获得锁时调用）</li>
</ul>
<p>如果一个线程已经锁定了某个互斥量，再次锁定时，对于 mutex，是危险的未定义行为。</p>
<p>如果有特殊需要可能在同一线程对同一个互斥量多次加锁，需要用到递归锁 recursive_mutex ，除了允许同一线程可以无阻塞地多次加锁外（也必须有对应数量的解锁操作），recursive_mutex 其他行为和 mutex 一致。</p>
<p>C++ 标准库还提供了：</p>
<ul>
<li>timed_mutex：允许锁定超时的互斥量</li>
<li>recursive_timed_mutex：允许锁定超时的递归互斥量</li>
<li>shared_mutex：允许共享和独占两种获得方式的互斥量</li>
<li>shared_timed_mutex：允许共享和独占两种获得方式的、允许锁定超时的互斥量</li>
</ul>
<blockquote>
<p>头文件<code>&lt;mutex&gt;</code>中定义了锁的 RAII 包装类（如<code>lock_guard</code>），避免手动加锁、解锁的麻烦，以及在有异常或出错返回时发生漏解锁，一般应当使用 lock_guard，而不是手工调用互斥量的 lock 和 unlock 方法。</p>
</blockquote>
<h2 id="thread">thread</h2>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread></span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

mutex output_lock<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">1000</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">></span> guard<span class="token punctuation">&#123;</span> output_lock <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    thread t1<span class="token punctuation">&#123;</span> fun<span class="token punctuation">,</span> <span class="token string">"A"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    thread t2<span class="token punctuation">&#123;</span> fun<span class="token punctuation">,</span> <span class="token string">"B"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/*
B
A
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>在 Linux 上编译线程相关的代码都需要加上 -pthread 命令行参数。</p>
</blockquote>
<p>这里使用互斥量（mutex）锁定 cout，防止输出交错到一起（输出BA）。</p>
<p>程序流程如下：</p>
<ol type="1">
<li>传递参数，起两个线程</li>
<li>两个线程分别休眠 1000ms</li>
<li>使用互斥量（mutex）锁定 cout ，然后输出一行信息</li>
<li>主线程等待这两个线程退出后程序结束</li>
</ol>
<blockquote>
<p>thread 的构造函数的第一个参数是函数（对象），后面跟的是这个函数所需的参数。</p>
<p>thread 要求在析构之前 join（阻塞直到线程退出）或 detach（放弃对线程的管理），否则程序会异常退出。</p>
<p>sleep_for 是 this_thread 名空间下的一个自由函数，表示当前线程休眠指定的时间。</p>
<p>没有 output_lock 的同步，输出通常会交错到一起。</p>
</blockquote>
<h2 id="thread-封装">thread 封装</h2>
<p>thread 不能在析构时自动 join （C++20有jthread），简单封装一下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">m_jthread</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token comment">// 使用可变模板和完美转发来构造 thread 对象</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Arg<span class="token operator">></span>
    <span class="token function">m_jthread</span><span class="token punctuation">(</span>Arg<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> arg<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">m_thread</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Arg<span class="token operator">></span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    
    <span class="token comment">// thread 可以移动</span>
    <span class="token function">m_jthread</span><span class="token punctuation">(</span>m_jthread<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token operator">:</span> <span class="token function">m_thread</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>m_thread<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    
    <span class="token comment">// thread 不能拷贝，禁用拷贝构造</span>
    <span class="token function">m_jthread</span><span class="token punctuation">(</span><span class="token keyword">const</span> m_jthread<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 析构时自动 join</span>
    <span class="token operator">~</span><span class="token function">m_jthread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>m_thread<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  m_thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>
    
    m_jthread<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>m_jthread<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
	<span class="token punctuation">&#123;</span> 
    	<span class="token function">m_jthread</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>m_jthread<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
	<span class="token punctuation">&#123;</span>
    	std<span class="token operator">::</span><span class="token function">swap</span><span class="token punctuation">(</span>m_thread<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>m_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
    
<span class="token keyword">private</span><span class="token operator">:</span>
    thread m_thread<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">m_jthread t1<span class="token punctuation">&#123;</span> fun<span class="token punctuation">,</span> <span class="token string">"A"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
m_jthread t2<span class="token punctuation">&#123;</span> fun<span class="token punctuation">,</span> <span class="token string">"B"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="锁">锁</h2>
<p>锁的本质属性是为事物提供<strong>访问保护</strong>。</p>
<p><strong>无锁</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">10</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">++</span>cnt<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> L <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
	m_jthread ts<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		ts<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> m_jthread<span class="token punctuation">&#123;</span>fun<span class="token punctuation">,</span> L<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"cnt: "</span> <span class="token operator">&lt;&lt;</span> cnt <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出</p>
<blockquote>
<p>cnt:992</p>
</blockquote>
<p>由于++cnt不是原子操作，而是由多条汇编指令完成的。多个线程对同一个变量进行读写操作就会出现不可预期的操作。如果线程1读取到了100，线程2也读取到了100，分别执行自增操作，线程1和线程2分别将自增的结果写回cnt，不管写入的顺序如何，counter都会是101，但是线程1和线程2分别执行了操作，期望的结果是102。</p>
<p><strong>加锁</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">mutex mtx<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">10</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">++</span>cnt<span class="token punctuation">;</span>
		mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出</p>
<blockquote>
<p>cnt:1000</p>
</blockquote>
<ul>
<li>对于std::mutex对象，任意时刻最多允许一个线程对其进行上锁。</li>
<li>lock()：调用该函数的线程尝试加锁。如果上锁不成功，即：其它线程已经上锁且未释放，则当前线程block。如果上锁成功，则执行后面的操作，操作完成后要调用unlock()释放锁，否则会导致死锁的产生。</li>
<li>try_lock()：尝试上锁，与mtx.lock()的不同点在于：如果上锁不成功，<strong>当前线程不阻塞</strong>。</li>
</ul>
<p><strong>死锁</strong></p>
<p>考虑这样一个情况：假设线程1上锁成功，线程2上锁等待。但是线程1上锁成功后，抛出异常并退出，没有来得及释放锁，导致线程2永久的等待下去，此时就发生了死锁。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">1</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">++</span>cnt<span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">throw</span> <span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"runtime_error 666"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">fun_t</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">try</span><span class="token punctuation">&#123;</span>
		<span class="token function">fun</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"cnt: "</span> <span class="token operator">&lt;&lt;</span> cnt <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> L <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
	m_jthread ts<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		ts<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> m_jthread<span class="token punctuation">&#123;</span>fun_t<span class="token punctuation">,</span> L<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出</p>
<blockquote>
<p>cnt: 100, runtime_error 666</p>
</blockquote>
<p><strong>lock_guard 避免死锁</strong></p>
<ul>
<li>std::lock_guard对象构造时，自动调用mtx.lock()进行上锁</li>
<li>std::lock_guard对象析构时，自动调用mtx.unlock()释放锁</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> L<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">m_mtx</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">==</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			<span class="token keyword">throw</span> <span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"runtime_error 666"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">1</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">++</span>cnt<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">fun_t</span><span class="token punctuation">(</span><span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">try</span><span class="token punctuation">&#123;</span>
		<span class="token function">fun</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"cnt: "</span> <span class="token operator">&lt;&lt;</span> cnt <span class="token operator">&lt;&lt;</span> <span class="token string">", "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> L <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
	m_jthread ts<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		ts<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> m_jthread<span class="token punctuation">&#123;</span>fun_t<span class="token punctuation">,</span> L<span class="token punctuation">,</span> i<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出</p>
<blockquote>
<p>cnt: 119, runtime_error 666 cnt: 900</p>
</blockquote>
<p>c++还提供了lock_guard的加强版 uniqe_lock，它提供了更多的接口，使其更加灵活，但性能方面也会有些受损。</p>
<h2 id="返回数据">返回数据</h2>
<p>要在某个线程执行一些后台任务，然后取回结果，传统的做法是使用信号量或者条件变量。</p>
<p>C++17 不支持信号量，要模拟传统的做法，只能用条件变量。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable></span> <span class="token comment">// 条件变量</span></span>

<span class="token keyword">void</span> <span class="token function">calculate</span><span class="token punctuation">(</span>condition_variable<span class="token operator">&amp;</span> cv<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// 计算时间 3s</span>
    this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">3</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    val <span class="token operator">=</span> <span class="token number">666</span><span class="token punctuation">;</span>
    cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    condition_variable cv<span class="token punctuation">;</span> 
    mutex cv_m<span class="token punctuation">;</span> 
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
    m_jthread t<span class="token punctuation">&#123;</span> calculate<span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span>cv<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token comment">// do others</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"waiting"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> 
    unique_lock lock<span class="token punctuation">&#123;</span> cv_m <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> 
    cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"val: "</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用 ref 模板告诉 thread 的构造函数，需要传递条件变量和结果变量的引用，因为 thread 默认复制或移动所有的参数作为线程函数的参数。这种复杂性并非逻辑上的复杂性，而只是实现导致的，不是我们希望的写代码的方式。</p>
<h2 id="notify_one-与-notify_all">notify_one() 与 notify_all()</h2>
<p>notify_one()：只唤醒等待队列中的第一个线程；不存在锁争用，能够立即获得锁。其余的线程不会被唤醒，需要等待再次调用notify_one()或者notify_all()。</p>
<p>notify_all()：会唤醒所有等待队列中阻塞的线程，存在锁争用，只有一个线程能够获得锁。其余未获取锁的线程会继续尝试获得锁，当持有锁的线程释放锁时，这些线程中的一个会获得锁，而其余的会接着尝试获得锁。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">mutex mtx<span class="token punctuation">;</span>
condition_variable cv<span class="token punctuation">;</span>
<span class="token keyword">bool</span> ready <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">></span> <span class="token function">lck</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>ready<span class="token punctuation">)</span> cv<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lck<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread: "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> <span class="token function">lck</span><span class="token punctuation">(</span>mtx<span class="token punctuation">)</span><span class="token punctuation">;</span>
	ready <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	cv<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// cv.notify_one()</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    m_jthread threads<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">m_jthread</span><span class="token punctuation">(</span>fun<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread start..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用gcc编译：<code>gcc -o main main.cpp -lstdc++ -static</code>，-static 防止找不到程序输入点。</p>
<p>输出如下，线程启动不全，并且程序没有退出，一直处于阻塞状态。</p>
<blockquote>
<p>thread start... thread: 0 thread: 6 thread: 7 thread: 8</p>
</blockquote>
<p>改为notify_all()，输出如下，线程全部启动，程序退出。</p>
<blockquote>
<p>thread start... thread: 9 thread: 6 thread: 7 thread: 8 thread: 5 thread: 4 thread: 3 thread: 2 thread: 1 thread: 0</p>
</blockquote>
<h2 id="future">future</h2>
<p>使用 async 会返回一个future。</p>
<blockquote>
<p>async 也不是真正的异步，而是封装的多线程。</p>
<p>C++20 都没有提供完整的异步支持，因为 I/O 方面的异步没有标准化，可以看看 Boost.Asi。</p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">3</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">666</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token comment">// #include &lt;future> </span>
	<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token function">async</span><span class="token punctuation">(</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span> fun<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 666</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>fun 函数不需要考虑条件变量之类的实现细节了，返回结果就可以了。</p></li>
<li><p>用 async 获得一个未来量，launch::async 是运行策略，告诉函数模板 async 在新线程里异步调用目标函数。</p>
<blockquote>
<p>在一些老版本的 GCC 里，不指定运行策略，默认不会起新线程。</p>
</blockquote></li>
<li>async 函数模板可以根据参数来推导出返回类型，这里返回类型是 <code>future&lt;int&gt;</code>。</li>
<li><p>未来量上调用 get 成员函数可以获得其结果。这个结果可以是返回值，也可以是异常，如果 fun 抛出了异常，main 里在执行 f.get() 时也会得到同样的异常，需要有相应的异常处理代码程序才能正常工作。</p></li>
</ul>
<p><strong>注意</strong></p>
<p>一个 future 上只能调用一次 get 函数，第二次调用为未定义行为，通常导致程序崩溃。</p>
<p>一个 future 是不能直接在多个线程里用的，可以直接拿 future 来移动构造一个 shared_future，或调用 future 的 share 方法来生成一个 shared_future，结果就可以在多个线程里用。每个 shared_future 只能调用一次 get 函数。</p>
<p>future执行get函数的时候，如果此时还没生成结果，就是阻塞等待了，直到有返回值为止。</p>
<h2 id="promise">promise</h2>
<p>用 promise 的实现方式。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">3</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	p<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> p<span class="token punctuation">;</span>
	<span class="token keyword">auto</span> f <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	m_jthread t1<span class="token punctuation">&#123;</span>fun<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 666</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>promise 和 future 在这里成对出现，可以看作是一个一次性管道。</p>
<p><code>std::move(p)</code>把 prom 移动给新线程，老线程就不需要管理它的生命周期了。</p>
<blockquote>
<p>需要注意的是，一组 promise 和 future 只能使用一次，既不能重复设，也不能重复取。</p>
<p>promise 和 future 还有个有趣的用法是使用 void 类型模板参数，这种情况下，两个线程之间不是传递参数，而是进行同步：当一个线程在一个 future 上等待时（使用 get() 或 wait()），另外一个线程可以通过调用 promise 上的 set_value() 让其结束等待、继续往下执行。</p>
</blockquote>
<h2 id="packaged_task">packaged_task</h2>
<p>打包任务 packaged_task。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token number">3</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">666</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span> p_t<span class="token punctuation">&#123;</span>fun<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> f <span class="token operator">=</span> p_t<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	m_jthread t1<span class="token punctuation">&#123;</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>p_t<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 666</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>打包任务里打包的是一个函数，模板参数是一个函数类型。跟 thread、future、promise 一样，packaged_task 只能移动，不能复制。它是个函数对象，可以像正常函数一样被执行，也可以传递给 thread 在新线程中执行。可以从它得到一个未来量。通过这个未来量，可以得到打包任务的返回值，或者至少知道这个打包任务已经执行结束了。</p>
<h2 id="执行顺序">执行顺序</h2>
<p>下面的事实可能会产生不符合直觉预期的结果：</p>
<ul>
<li>为了优化的必要，编译器是可以调整代码的执行顺序的。唯一的要求是，程序的可观测外部行为是一致的。</li>
<li>处理器会对代码的执行顺序进行调整（所谓的 CPU 乱序执行）。在单处理器的情况下，这种乱序无法被程序观察到；在多处理器的情况下，在另一个处理器上运行的另一个线程就可能会察觉到这种不同顺序的后果。</li>
</ul>
<p>假设我们有两个全局变量：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在线程1里执行：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在线程2里执行：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span>y <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    y <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>可能出现 x = 1，y = 4 的情况，原因如下：</p>
<ul>
<li>编译器没有义务一定按代码里给出的顺序产生代码。跟据上下文调整代码的执行顺序，使其最有利于处理器的架构，是优化中很重要的一步。就单个线程而言，先执行 x = 1 和先执行 y = 2 是无关紧要的，没有外部可观察的区别。</li>
<li>在多处理器架构中，各个处理器可能存在缓存不一致性问题。取决于具体的处理器类型、缓存策略和变量地址，对变量 b 的写入有可能先反映到主内存中去。之所以这个问题似乎并不常见，是因为常见的 x86 和 x86-64 处理器是在顺序执行方面做得最保守的，大部分其他处理器，如 ARM、DEC Alpha、PA-RISC、IBM Power、IBM z/ 架构和 Intel Itanium 在内存序问题上都比较松散。x86 使用的内存模型基本提供了顺序一致性（sequential consistency）；相对的，ARM 使用的内存模型就只是松散一致性（relaxed consistency）。</li>
<li>虽说 Intel 架构处理器的顺序一致性比较好，但在多处理器（包括多核）的情况下仍然能够出现写读序列变成读写序列的情况，产生意料之外的后果。</li>
</ul>
<p><strong>volatile</strong></p>
<p>在某些编译器里用 volatile 可以达到内存同步效果。这不是 volatile 设计意图，也不能通用地达到内存同步效果。volatile 的语义只是防止编译器优化掉对内存的读写，合适用法主要是用来读写映射到内存地址上的 I/O 操作。</p>
<p>由于 volatile 不能在多处理器的环境下确保多个线程能看到同样顺序的数据变化，在通用应用程序中，不应该再看到 volatile 的出现。</p>
<h2 id="c11-内存模型">C++11 内存模型</h2>
<p>C++11 里引入了适合多线程的内存模型，有了原子对象（atomic）和使用原子对象的获得（acquire）、释放（release）语义，可以真正精确地控制内存访问的顺序性，保证我们需要的内存序。</p>
<p>上面的例子中，如果我们希望只能是 1、2 或 3、4，即满足完全存储序（total store ordering）。</p>
<p>需要在 x = 1 和 y = 2 两语句之间加入内存屏障，禁止这两句语句交换顺序。最常用的两个概念是获得和释放：</p>
<ul>
<li><strong>获得</strong>是一个对内存的读操作，当前线程的任何后面的读写操作都不允许重排到这个操作的<strong>前面</strong>去。</li>
<li><strong>释放</strong>是一个对内存的写操作，当前线程的任何前面的读写操作都不允许重排到这个操作的<strong>后面</strong>去。</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>线程1使用释放语义，确保 b 的赋值在 a 后面。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>线程2使用获得语义，确保判断语句在前面；存储用松散内存序即可，这里a、b存储语句执行先后不影响结果。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>memory_order_acquire<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面的图可以看出：每一边的代码都不允许重排越过黄色区域，且如果 y 上的释放早于 y 上的获取的话，释放前对内存的修改都在另一个线程的获取操作后可见。</p>
<figure>
<img src="https://raw.githubusercontent.com/morisa66/BlogImgs/master/cpp/Concurrency/atomic.png" alt="img" / loading="lazy"><figcaption>img</figcaption>
</figure>
<p>把 y 改成 atomic 之后，两个线程的代码一行不改，执行结果都会是符合我们的期望的。因为 atomic 变量的写操作缺省就是释放语义，读操作缺省就是获得语义。即：</p>
<ul>
<li>y = 2 相当于 y.store(2, memory_order_release)</li>
<li>y == 2 相当于 y.load(memory_order_acquire) == 2</li>
</ul>
<blockquote>
<p>缺省行为可能是对性能不利的：我们并不需要在任何情况下都保证操作的顺序性。 另外，acquire 和 release 通常都是配对出现的，目的是保证如果对同一个原子对象的 release 发生在 acquire 之前的话，release 之前发生的内存修改能够被 acquire 之后的内存读取全部看到。</p>
</blockquote>
<h2 id="atomic">atomic</h2>
<p>C++11 在头文件 <code>&lt;atomic&gt;</code>中引入了 atomic 模板，对原子对象进行了封装，可以将其应用到任何类型上去。</p>
<ul>
<li>对于整型量和指针等简单类型，通常结果是无锁的原子对象。</li>
<li>而对于另外一些类型，比如 64 位机器上大小不是 1、2、4、8（有些平台 / 编译器也支持对更大的数据进行无锁原子操作）的类型，编译器会自动为这些原子对象的操作加上锁。</li>
<li>编译器提供了一个原子对象的成员函数 is_lock_free，可以检查这个原子对象上的操作是否是无锁的。</li>
</ul>
<p>原子操作有三类：</p>
<ul>
<li>读：在读取的过程中，读取位置的内容不会发生任何变动。</li>
<li>写：在写入的过程中，其他执行线程不会看到部分写入的结果。</li>
<li>读‐修改‐写：读取内存、修改数值、然后写回内存，整个操作的过程中间不会有其他写入操作插入，其他执行线程不会看到部分写入的结果</li>
</ul>
<p><code>&lt;atomic&gt;</code>定义的内存序：</p>
<ul>
<li>memory_order_relaxed：松散内存序，只用来保证对原子对象的操作是原子的</li>
<li>emory_order_consume：目前不鼓励使用</li>
<li>memory_order_acquire：获得操作，在读取某原子对象时，当前线程的任何后面的读写操作都不允许重排到这个操作的前面去，并且其他线程在对同一个原子对象释放之前的所有内存写入都在当前线程可见</li>
<li>memory_order_release：释放操作，在写入某原子对象时，当前线程的任何前面的读写操作都不允许重排到这个操作的后面去，并且当前线程的所有内存写入都在对同一个原子对象进行获取的其他线程可见</li>
<li>memory_order_acq_rel：获得释放操作，一个读‐修改‐写操作同时具有获得语义和释放语义，即它前后的任何读写操作都不允许重排，并且其他线程在对同一个原子对象释放之前的所有内存写入都在当前线程可见，当前线程的所有内存写入都在对同一个原子对象进行获取的其他线程可见</li>
<li>memory_order_seq_cst：顺序一致性语义，对于读操作相当于获取，对于写操作相当于释放，对于读‐修改‐写操作相当于获得释放，是所有原子操作的默认内存序</li>
</ul>
<blockquote>
<p>这里的可见可以理解成<strong>获得和释放操作的两个线程能观察到相同的内存修改结果</strong>。</p>
</blockquote>
<p>atomic 常用的成员函数：</p>
<ul>
<li>默认构造函数（只支持零初始化）</li>
<li>拷贝构造函数被删除</li>
<li>使用内置对象类型的构造函数（不是原子操作）</li>
<li>可以从内置对象类型赋值到原子对象（相当于 store</li>
<li>可以从原子对象隐式转换成内置对象（相当于 load）</li>
<li>store，写入对象到原子对象里，第二个可选参数是内存序类型</li>
<li>load，从原子对象读取内置对象，有个可选参数是内存序类型</li>
<li>is_lock_free，判断对原子对象的操作是否无锁（是否可以用处理器的指令直接完成原子操作）</li>
<li>exchange，交换操作，第二个可选参数是内存序类型（这是读‐修改‐写操作）</li>
<li>compare_exchange_weak 和 compare_exchange_strong，两个比较加交换（CAS）的版本，你可以分别指定成功和失败时的内存序，也可以只指定一个，或使用默认的最安全内存序（这是读‐修改‐写操作）</li>
<li>fetch_add 和 fetch_sub，仅对整数和指针内置对象有效，对目标原子对象执行加或减操作，返回其原始值，第二个可选参数是内存序类型（这是读‐修改‐写操作）</li>
<li>++ 和 --（前置和后置），仅对整数和指针内置对象有效，对目标原子对象执行增一或减一，操作使用顺序一致性语义，并注意返回的不是原子对象的引用（这是读‐修改‐写操作）</li>
<li>+= 和 -=，仅对整数和指针内置对象有效，对目标原子对象执行加或减操作，返回操作之后的数值，操作使用顺序一致性语义，并注意返回的不是原子对象的引用（这是读‐修改‐写操作）</li>
</ul>
<p>可以将 m_shared_ptr 修改为线程安全版本。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//#include&lt;atomic></span>

<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token comment">// 在 increase 中执行简单的 ++、使用顺序一致性语义略有浪费，下面的做法更合理：</span>
	<span class="token keyword">void</span> <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">noexcept</span> 
	<span class="token punctuation">&#123;</span> 
		count<span class="token punctuation">.</span><span class="token function">fetch_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token comment">//long count;</span>
	std<span class="token operator">::</span>atomic_long count<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="安全双重检查锁定">安全双重检查锁定</h2>
<p>在多线程可能对同一个单件进行初始化的情况下，有一个双重检查锁定的技巧。</p>
<p>目的是消除大部分执行路径上的加锁开销。原本的意图是：如果 inst_ptr 没有被初始化，执行才会进入加锁的路径，防止单件被构造多次；如果 inst_ptr_ 已经被初始化，那它就会被直接返回，不会产生额外的开销。但即使花上再大的力气，这个用法仍然有着非常多的难以填补的漏洞。本质上还是上面说的，优化编译器会努力击败你试图想防止优化的努力，而多处理器会以令人意外的方式让代码走到错误的执行路径上去。</p>
<ul>
<li>互斥量的加锁操作（lock）具有获得语义</li>
<li>互斥量的解锁操作（unlock）具有释放语义</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">singleton</span> 
<span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">static</span> singleton<span class="token operator">*</span> <span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">static</span> std<span class="token operator">::</span>mutex lock<span class="token punctuation">;</span>
	<span class="token keyword">static</span> std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span>singleton<span class="token operator">*</span><span class="token operator">></span> inst_ptr<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

std<span class="token operator">::</span>mutex singleton<span class="token operator">::</span>lock<span class="token punctuation">;</span>
std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span>singleton<span class="token operator">*</span><span class="token operator">></span> singleton<span class="token operator">::</span>inst_ptr<span class="token punctuation">;</span>
  
singleton<span class="token operator">*</span> singleton<span class="token operator">::</span><span class="token function">instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	singleton<span class="token operator">*</span> ptr <span class="token operator">=</span> inst_ptr<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    	std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">></span> guard<span class="token punctuation">&#123;</span>lock<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    	ptr <span class="token operator">=</span> inst_ptr<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    	<span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      		ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      		inst_ptr<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>     
    	<span class="token punctuation">&#125;</span>
  	<span class="token punctuation">&#125;</span>
  	<span class="token keyword">return</span> inst_ptr<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>为了和 inst_ptr.load 语句对称，在 inst_ptr.store 时使用了释放语义；不过，由于互斥量解锁本身具有释放语义，这么做并不是必需的。</p>
<p>这里要double check其实是赋值顺序的问题。至少在某些处理器上，其他线程可能先看到 inst_ptr 被修改，再看到单件的构造完成。</p>
</blockquote>
<h2 id="一些问题">一些问题</h2>
<ul>
<li>原则上任何多线程访问的变量应该要么是原子量，要么有互斥量来保护。特别要考虑内存序的，就是有多个有逻辑相关性的共享变量。对于单个的变量，比如检查线程是否应该退出的布尔变量，只要消除了编译器优化，不需要保证访问顺序也可以正常工作；这样原子量可以使用 relaxed 的访问方式。</li>
<li>用原子量的地方，用互斥量加锁都可以。但如果锁导致阻塞的话，性能比起原子量那是会有好几个数量级的差异了。锁即使不导致阻塞，性能也会比原子量低。锁本身的实现就会用到原子量，是个复杂的复合操作。</li>
<li>用互斥量加锁的地方不能都改用原子量。原子量本身没有阻塞机制，没有保护代码段的功能。</li>
<li>对单独没有逻辑联系的变量，直接使用原子量的relaxed就够了，没必要加上内存序。</li>
<li>对于有联系的多个多线程中的变量，需要考虑使用原子量的内存序。</li>
<li>对于代码段的保护，由于原子量没有阻塞，必须使用互斥量和锁来解决。</li>
<li>互斥量是个对象，（加/解）锁是互斥量支持的动作。</li>
</ul>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">If it is useful, and you would like to help me, please Money🤡Money🤡Money🤡!</div><div id="qr" style="display:none;"><div style="display:inline-block"><a href="/imgs/pay/zfb.jpg"><img loading="lazy" src="/imgs/pay/zfb.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a href="/imgs/pay/wx.png"><img loading="lazy" src="/imgs/pay/wx.png" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>morisa</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://morisa66.github.io/2021/02/12/Concurrency/" title="并发Concurrency">https://morisa66.github.io/2021/02/12/Concurrency/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/02/15/Coroutines/" rel="prev" title="协程 Coroutines"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">协程 Coroutines</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/02/02/FastMod/" rel="next" title="快速幂"><span class="post-nav-text">快速幂</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> morisa</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.5.1</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>